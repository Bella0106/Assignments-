a) Approach
inputs : list of the monthly slaes values numbers for given year and each month is paired with it's sales value ( Jan:100,Feb:113..Dec:63)
Desired output: The starting month and ending month of the group of months in a row that have the highest total sales. Also, the total sales amount for that group.
* Start month
*End month 
* Total sales for that stretch 


b) implementation( C++)
```C++
#include <iostream>
#include <vector>
#include <string>
using namespace std;

struct Result {
    int startIndex;
    int endIndex;
    int maxSum;
};

Result maxSalesSubarray(const vector<int>& sales) {
    size_t n = sales.size();
    int currentSum = sales[0];
    int maxSum = sales[0];
    int start = 0, end = 0, tempStart = 0;

    for (int i = 1; i < n; i++) {
        if (currentSum < 0) {
            currentSum = sales[i];
            tempStart = i;
        } else {
            currentSum += sales[i];
        }

        if (currentSum > maxSum) {
            maxSum = currentSum;
            start = tempStart;
            end = i;
        }
    }
    return {start, end, maxSum};
}

int main() {
    vector<string> months = {
        "January","February","March","April","May","June",
        "July","August","September","October","November","December"
    };

    vector<int> sales = {100,113,110,85,81,101,94,106,105,102,86,63};

    Result res = maxSalesSubarray(sales);

    cout << "Best stretch: " << months[res.startIndex]
         << " to " << months[res.endIndex] << endl;
    cout << "Total Sales: " << res.maxSum << " million USD" << endl;

    return 0;
}

c) Pseudocode+Complexity 
Pseudocode (Kadane's algorithm style ) 
function maxSalesSubarray(sales):
    currentSum = sales[0]
    maxSum = sales[0]
    start = 0
    end = 0
    tempStart = 0

    for i from 1 to length(sales)-1:
        if currentSum < 0:
            currentSum = sales[i]
            tempStart = i
        else:
            currentSum = currentSum + sales[i]

        if currentSum > maxSum:
            maxSum = currentSum
            start = tempStart
            end = i

    return (start, end, maxSum)

d) Limitations 

If one month is very big, it might hide other good months. Noise/Outliner A single very large month can dominate the result, even if the surrounding months are low 

Only finds one best stretch of months.

The algorithm finds just one best run. It doesnâ€™t consider repeating seasonal peaks like summer sales being high.

If two stretches are equal, we pick the first one.
