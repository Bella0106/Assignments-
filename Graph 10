1. Create a theoretical graph using a pen and paper OR electronically. 

    5       4          7       6
     \     /             \     /
       \ /                 \ /
        1 ---------------  2 --------------- 3

2. Implement the graph created in step 1 and apply breadth and depth-first search algorithms using C++
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

// Function for BFS
void BFS(int start, vector<vector<int>>& graph, int n) {
    vector<bool> visited(n + 1, false);
    queue<int> q;

    visited[start] = true;
    q.push(start);

    cout << "BFS starting from node " << start << ": ";

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        cout << node << " ";

        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                q.push(neighbor);
            }
        }
    }
    cout << endl;
}

// Function for DFS
void DFSUtil(int node, vector<vector<int>>& graph, vector<bool>& visited) {
    visited[node] = true;
    cout << node << " ";

    for (int neighbor : graph[node]) {
        if (!visited[neighbor]) {
            DFSUtil(neighbor, graph, visited);
        }
    }
}

void DFS(int start, vector<vector<int>>& graph, int n) {
    vector<bool> visited(n + 1, false);
    cout << "DFS starting from node " << start << ": ";
    DFSUtil(start, graph, visited);
    cout << endl;
}

int main() {
    int n = 7; 
    vector<vector<int>> graph(n + 1);

    graph[1] = {2, 4, 5};
    graph[2] = {1, 3, 6, 7};
    graph[3] = {2};
    graph[4] = {1};
    graph[5] = {1};
    graph[6] = {2};
    graph[7] = {2};

    BFS(1, graph, n);
    DFS(1, graph, n);

    return 0;
}

3. Compare both search algorithms in the context of Big O notations. 
The most widely used methods are Breadth-First Search (BFS) and Depth-First Search (DFS) 
----Time complexity----
BFS = O(V + E) 
DFS = O(V + E)
----Space complexity---
BFS = O(V)
DFS = O(V)
----Path finding----
BFS = looks at nodes level by level, visiting all neighbors before going deeper.
DFS = goes deep along one path before backtracking.
----Completenese----
BFS = Always find solution if exist 
DFS = May get stuck in infinite depth 
----Use Cases----
BFS = Shortest path, web crawling 
DFS = Topological sort , cycle detection 

This is ny video 
https://youtu.be/Ll9W3DRJzho

